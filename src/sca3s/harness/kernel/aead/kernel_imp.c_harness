/* Copyright (C) 2018 SCARV project <info@scarv.org>
 *
 * Use of this source code is restricted per the MIT license, a copy of which 
 * can be found at https://opensource.org/licenses/MIT (or should be included 
 * as LICENSE.txt within the associated archive or repository).
 */

// ============================================================================

#if   ( KERNEL_NAMEOF == KERNEL_NAMEOF_GENERIC )
#define __KERNEL_NAMEOF "generic"
#endif

#if   ( KERNEL_MODEOF == KERNEL_MODEOF_ENC     )
#define __KERNEL_MODEOF "enc"
#elif ( KERNEL_MODEOF == KERNEL_MODEOF_DEC     )
#define __KERNEL_MODEOF "dec"
#endif

#define KERNEL_ID VERSION ":" KERNEL ":" __KERNEL_NAMEOF "/" __KERNEL_MODEOF

#pragma message( "?data tsc"    " = "     "0"              )
#pragma message( "?data k"      " = " INT(KERNEL_SIZEOF_K) )
#pragma message( "?data a"      " = " INT(KERNEL_SIZEOF_A) )
#pragma message( "?data m"      " = " INT(KERNEL_SIZEOF_M) )
#pragma message( "?data c"      " = " INT(KERNEL_SIZEOF_C) )

#pragma message( "#data tsc"    " = "     "0"              )
#pragma message( "#data k"      " = " INT(KERNEL_SIZEOF_K) )
#pragma message( "#data a"      " = " INT(KERNEL_SIZEOF_A) )
#pragma message( "#data m"      " = " INT(KERNEL_SIZEOF_M) )
#pragma message( "#data c"      " = " INT(KERNEL_SIZEOF_C) )

#pragma message( "?kernel_id"   " = "     KERNEL_ID        )

#if   ( KERNEL_MODEOF == KERNEL_MODEOF_ENC )
#pragma message( ">kernel_data" " = "     "k,a,m"          )
#pragma message( "<kernel_data" " = " "tsc,c"              )
#elif ( KERNEL_MODEOF == KERNEL_MODEOF_DEC )
#pragma message( ">kernel_data" " = "     "k,a,c"          )
#pragma message( "<kernel_data" " = " "tsc,m"              )
#endif

// ============================================================================

/** @brief      A register that contains cipher key.
  */

uint8_t k[ KERNEL_SIZEOF_K ] = { KERNEL_INITOF_K };

/** @brief      A register that contains associated data.
  */

uint8_t a[ KERNEL_SIZEOF_A ] = { KERNEL_INITOF_A };

/** @brief      A register that contains  plaintext data.
  */

uint8_t m[ KERNEL_SIZEOF_M ] = { KERNEL_INITOF_M };

/** @brief      A register that contains ciphertext data.
  */

uint8_t c[ KERNEL_SIZEOF_C ] = { KERNEL_INITOF_C };

/** @brief      Number of used bytes in register that contains cipher key.
  */

uint8_t n_k = 0;

/** @brief      Number of used bytes in register that contains associated data.
  */

uint8_t n_a = 0;

/** @brief      Number of used bytes in register that contains  plaintext data.
  */

uint8_t n_m = 0;

/** @brief      Number of used bytes in register that contains ciphertext data.
  */

uint8_t n_c = 0;

/** @brief      Generate a kernel identifier string.
  *
  * @param[out] x a (pointer to a) buffer into which the identifier string is copied
  *
  * @note       By convention, the identifier string constitutes a sequence 
  *             of colon-separated fields; to allow the string to be parsed, 
  *             the first two fields must be \c VERSION and \c KERNEL.
  */

void kernel_id( char* x ) {
  strcpy( x, KERNEL_ID );
}

bool kernel_prologue();
bool kernel();
bool kernel_epilogue();

/** @brief      A specification of the
  *             registers
  *             accessible within the kernel.
  *
  * @note       By setting \c .id equal to \c NULL, the entry will act as a
  *             terminator for the array; such a terminator entry must exist
  *             as the final entry.
  */

kernel_data_spec_t kernel_data_spec[] = {
// kernel-agnostic
  { .id = "tsc", .data = ( uint8_t* )( &kernel_tsc ), .used = ( uint8_t* )( NULL ), .size = SIZEOF( kernel_tsc ), .type = KERNEL_DATA_TYPE_O    },
// kernel-specific
  { .id =   "k", .data = ( uint8_t* )(           k ), .used = ( uint8_t* )( &n_k ), .size = SIZEOF(          k ), .type = KERNEL_DATA_TYPE_I    },
#if   ( KERNEL_MODEOF == KERNEL_MODEOF_ENC )
  { .id =   "a", .data = ( uint8_t* )(           a ), .used = ( uint8_t* )( &n_a ), .size = SIZEOF(          a ), .type = KERNEL_DATA_TYPE_I    },
  { .id =   "m", .data = ( uint8_t* )(           m ), .used = ( uint8_t* )( &n_m ), .size = SIZEOF(          m ), .type = KERNEL_DATA_TYPE_I    },
  { .id =   "c", .data = ( uint8_t* )(           c ), .used = ( uint8_t* )( &n_c ), .size = SIZEOF(          c ), .type = KERNEL_DATA_TYPE_O    },
#elif ( KERNEL_MODEOF == KERNEL_MODEOF_DEC )
  { .id =   "a", .data = ( uint8_t* )(           a ), .used = ( uint8_t* )( &n_k ), .size = SIZEOF(          a ), .type = KERNEL_DATA_TYPE_I    },
  { .id =   "c", .data = ( uint8_t* )(           c ), .used = ( uint8_t* )( &n_c ), .size = SIZEOF(          c ), .type = KERNEL_DATA_TYPE_I    },
  { .id =   "m", .data = ( uint8_t* )(           m ), .used = ( uint8_t* )( &n_m ), .size = SIZEOF(          m ), .type = KERNEL_DATA_TYPE_O    },
#endif
// terminator
  { .id =  NULL, .data = ( uint8_t* )(        NULL ), .used = ( uint8_t* )( NULL ), .size =       (          0 ), .type = KERNEL_DATA_TYPE_NONE }
};

/** @brief      A specification of the
  *             functions
  *             accessible within the kernel.
  */

kernel_func_spec_t kernel_func_spec   = {
  .kernel_id       = kernel_id,

  .kernel_prologue = kernel_prologue,
  .kernel          = kernel,
  .kernel_epilogue = kernel_epilogue
};

// ============================================================================
